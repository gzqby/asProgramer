# 继承方式  
  
### 构造函数
```bash  
function parent() {
    this.name='parent';
    this.arr=[1,2];
  }
parent.prototype.talk=function(){
    console.log(`my name is ${this.name},hello everyone!`);
}
  
function child(name){
   parent.call(this);
   this.name=name;
}
  
let childa=new child('childa');
let childb=new child('childb');

console.log(childa.name+':'+childa.arr);
console.log(childb.name+':'+childb.arr);
childa.arr.push(98);
console.log(childa.name+':'+childa.arr);
console.log(childb.name+':'+childb.arr);
// 实例的对象的引用型属性也是互不干扰的

childa.talk();// TypeError: childa.talk is not a function.说明构造函数方式不能使用原型链上的方法！
```
  
### 原型链  
```bash
function parent() {
    this.name='parent';
    this.arr=[1,2];
}
parent.prototype.talk=function(){
    console.log(`my name is ${this.name},hello everyone!`);
}
  
function child(name){
    //parent.call(this);// 原型链继承再加上构造函数继承 ，也就是组合继承
    // 实例的对象的引用型属性也是互不干扰的
    this.name=name;
}
child.prototype=new parent();


let childa=new child('childa');
let childb=new child('childb');

console.log(childa.name+':'+childa.arr);
console.log(childb.name+':'+childb.arr);
childa.arr.push(98);
console.log(childa.name+':'+childa.arr);
console.log(childb.name+':'+childb.arr);


childa.talk();
```
