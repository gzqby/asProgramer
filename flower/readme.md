setBIgPriceColor函数，保持其传入值一致；在index2中能正常输出结果；在index1中会出现变量被定义在for循环中的一样的效果！(即每次对数组中一个值赋值会覆盖上一次的赋值！ )  
(代码运行在在老版本微软JS解析器，在node11和chrome71依然会出现这个情况)


最终解决：  
如果把这个函数单独拿出来，即index2中，只需把引用改写即可：returnArr = [].contac(returnArr);把returnArr中的二个二级数组拿出来也可以结果;再次测试引用不变也可以。  
在index1中，把returnArr里面的二级数组分别赋值，并且把引用改写，两个一起才能起到作用！
  
### +
最初写这个程序时间主要受限于C#的JS解析器问题，导出脚本只留下一个程序接口。
这个函数写出了bug,写完的时候只是找到解决办法实际为啥并不明确，猜想是引用指向关系。  
函数内部再定义函数，每次执行完外部函数内部函数会被回收，这个理念也是最初这么写程序的思路，就是为了它能垃圾回收。  
今天测试JS性能看了一些东西。又反方向思考一下，如果垃圾回收，相当于这个函数被从内存中剔除，下次再使用要重新创建，和正常的性能优化是相反的！
更多一点的性能，类自身的方法会在每次实例化重复创建多个函数性能也是不是最优的；自身的属性也是同样即变量私有化也是如此，但是确实推荐写法！  
综上性能优化其实也是一门艺术设计，应根据实际灵活分析是不是放入内存。（回到最初这个程序就作为脚本而言我的理解应该把内存释放）
